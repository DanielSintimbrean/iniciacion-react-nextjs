# useEffect

## Objetivo

- Ejecutar efectos secundarios tras el render (consultas, suscripciones,
  sincronizaci√≥n con APIs del navegador).
- Persistir el estado del contador en `localStorage` para que se mantenga entre
  recargas.
- Evitar errores comunes como dependencias incorrectas o accesos al DOM durante
  el render.

## Conceptos

### ¬øQu√© es un efecto?

Un efecto es c√≥digo que se ejecuta despu√©s de que React renderiza tu componente.
Se usa para sincronizar la UI con sistemas externos (por ejemplo,
`localStorage`, `fetch`, eventos del navegador, timers‚Ä¶).

`useEffect` tiene esta forma:

```ts
useEffect(() => {
  // Efecto: se ejecuta despu√©s del render
  return () => {
    // (opcional) Limpieza: se ejecuta antes del pr√≥ximo efecto o al desmontar
  };
}, [dependencias]);
```

### Contador persistente en localStorage

```tsx
"use client";

import { useEffect, useState } from "react";

const STORAGE_KEY = "counter:v1";

export function PersistentCounter() {
  const [count, setCount] = useState(0);

  // Obtener el n√∫mero de localstorage desdpu√©s del primer render
  useEffect(() => {
    const item = window.localStorage.getItem(STORAGE_KEY);
    const num = Number(item);

    if (!Number.isNa(num)) {
      setCount(num);
    }
  }, []);

  // Actulizar el localstorage
  useEffect(() => {
    window.localStorage.setItem(STORAGE_KEY, String(count));
  }, [count]);

  return (
    <div style={{ display: "flex", gap: 8, alignItems: "center" }}>
      <button onClick={() => setCount((c) => c - 1)}>-1</button>
      <span>{count}</span>
      <button onClick={() => setCount((c) => c + 1)}>+1</button>
      <button onClick={() => setCount(0)} disabled={count === 0}>
        Reset
      </button>
    </div>
  );
}
```

> [!NOTE]
>
> `useEffect` solo est√° disponible en Client Components. A√±ade `"use client"` en
> la primera l√≠nea del archivo del componente.

#### üìù Ejercicio

- [ ] Crear un componente `PersistentCounter` en
      `src/app/persistent-counter.tsx`.
- [ ] Leer el valor inicial desde `localStorage` y guardarlo cada vez que cambie
      `count`.
- [ ] A√±adir un bot√≥n "Reset" (deshabilitado si `count === 0`).
- [ ] A√±adir una prop opcional `storageKey?: string` con valor por defecto
      `"counter:v1"`.
- [ ] Renderizar dos contadores con claves distintas para comprobar que cada uno
      recuerda su valor.

## Errores comunes

**‚ùå Dependencias incorrectas en el efecto**

```tsx
// ‚ùå Incorrecto: falta 'count' en dependencias
useEffect(() => {
  window.localStorage.setItem("counter:v1", String(count));
}, []); // No se ejecutar√° cuando cambie count
```

```tsx
// ‚úÖ Correcto
useEffect(() => {
  window.localStorage.setItem("counter:v1", String(count));
}, [count]);
```

**‚ùå Efectos que provocan renders infinitos**

```tsx
// ‚ùå Incorrecto: actualizar estado sin condici√≥n dentro del efecto
useEffect(() => {
  setCount((c) => c + 1); // Esto dispara otro render ‚Üí bucle infinito
});
```

```tsx
// ‚úÖ Correcto: actualiza estado solo en respuesta a eventos o con l√≥gicas controladas
useEffect(() => {
  // sincronizaci√≥n con sistemas externos sin modificar estado sin control
}, []);
```

## Resumen de lo aprendido

- Entendiste cu√°ndo usar `useEffect` para sincronizar con sistemas externos.
- Persististe el estado del contador en `localStorage` de forma segura.
- Evitaste dependencias incorrectas y bucles de render.

## Recursos

- Documentaci√≥n oficial de `useEffect`:
  `https://es.react.dev/reference/react/useEffect`
- Client Components en Next.js:
  `https://nextjs.org/docs/app/building-your-application/rendering/client-components`
- `localStorage` en MDN:
  `https://developer.mozilla.org/docs/Web/API/Window/localStorage`
